/**
 * User API Client
 * 
 * This module provides a comprehensive API client for user-related operations.
 * It includes functions for user CRUD operations, authentication, and account management.
 * 
 * Features:
 * - Full TypeScript support with proper types
 * - Axios-based HTTP client with error handling
 * - Utility functions for common operations
 * - Support for all user endpoints
 * 
 * @example
 * ```typescript
 * import { userApi } from '~/api/users';
 * 
 * // Create a new user
 * const newUser = await userApi.createUser({
 *   name: 'John Doe',
 *   email: 'john@example.com',
 *   account_type: 'patient',
 *   password: 'securePassword123'
 * });
 * 
 * // Login user
 * const loginResult = await userApi.login({
 *   email: 'john@example.com',
 *   password: 'securePassword123',
 *   account_type: 'patient'
 * });
 * 
 * // Get user by ID
 * const user = await userApi.getUserById('user-id');
 * ```
 */

import axios, { AxiosResponse } from 'axios';
import { API_BASE_URL } from "~/api";
import type {
    CreateUserData,
    CreateUserRequest,
    EmailVerificationResponse,
    LoginRequest,
    UpdateUserData,
    User,
    UserStatusUpdate,
} from '~/components/user/types';

import {
    AccountStatus,
    AccountType,
} from '~/components/user/types';

// Create axios instance with default configuration
const apiClient = axios.create({
    baseURL: API_BASE_URL,
    headers: {
        'Content-Type': 'application/json',
    },
    timeout: 10000, // 10 second timeout
});


/**
 * User API operations
 */
export const userApi = {
    /**
     * Create a new user account
     * POST /user
     */
    async createUser(userData: CreateUserData): Promise<User> {
        try {
            const requestData: CreateUserRequest = {
                user: {
                    name: userData.name,
                    given_name: userData.given_name,
                    family_name: userData.family_name,
                    middle_name: userData.middle_name,
                    email: userData.email,
                    account_type: userData.account_type,
                    status: userData.status || AccountStatus.PENDING,
                    sub: '', // Will be generated by backend
                },
                password: userData.password,
            };

            const response: AxiosResponse<User> = await apiClient.post('/user', requestData);
            return response.data;
        } catch (error) {
            console.error('Error creating user:', error);
            throw new Error(
                axios.isAxiosError(error) && error.response?.data?.error
                    ? error.response.data.error
                    : 'Failed to create user'
            );
        }
    },

    /**
     * Get user by ID (sub)
     * GET /user/{id}
     */
    async getUserById(id: string): Promise<User> {
        try {
            const response: AxiosResponse<User> = await apiClient.get(`/user/${id}`);
            return response.data;
        } catch (error) {
            console.error('Error fetching user:', error);
            throw new Error(
                axios.isAxiosError(error) && error.response?.data?.error
                    ? error.response.data.error
                    : 'Failed to fetch user'
            );
        }
    },

    /**
     * List all users
     * GET /user
     */
    async listUsers(): Promise<User[]> {
        try {
            const response: AxiosResponse<User[]> = await apiClient.get('/user');
            return response.data;
        } catch (error) {
            console.error('Error fetching users:', error);
            throw new Error(
                axios.isAxiosError(error) && error.response?.data?.error
                    ? error.response.data.error
                    : 'Failed to fetch users'
            );
        }
    },

    /**
     * Update user information
     * PUT /user/{id}
     */
    async updateUser(id: string, userData: UpdateUserData): Promise<User> {
        try {
            const response: AxiosResponse<User> = await apiClient.put(`/user/${id}`, userData);
            return response.data;
        } catch (error) {
            console.error('Error updating user:', error);
            throw new Error(
                axios.isAxiosError(error) && error.response?.data?.error
                    ? error.response.data.error
                    : 'Failed to update user'
            );
        }
    },

    /**
     * Delete user account
     * DELETE /user/{id}
     */
    async deleteUser(id: string): Promise<void> {
        try {
            await apiClient.delete(`/user/${id}`);
        } catch (error) {
            console.error('Error deleting user:', error);
            throw new Error(
                axios.isAxiosError(error) && error.response?.data?.error
                    ? error.response.data.error
                    : 'Failed to delete user'
            );
        }
    },

    /**
     * Update user status
     * PATCH /user/{id}/status
     */
    async updateUserStatus(id: string, status: AccountStatus | string): Promise<User> {
        try {
            const requestData: UserStatusUpdate = { status };
            const response: AxiosResponse<User> = await apiClient.patch(`/user/${id}/status`, requestData);
            return response.data;
        } catch (error) {
            console.error('Error updating user status:', error);
            throw new Error(
                axios.isAxiosError(error) && error.response?.data?.error
                    ? error.response.data.error
                    : 'Failed to update user status'
            );
        }
    },

    /**
     * User login
     * POST /login
     */
    async login(credentials: LoginRequest): Promise<User> {
        try {
            const response: AxiosResponse<User> = await apiClient.post('/login', credentials);
            return response.data;
        } catch (error) {
            console.error('Error during login:', error);
            throw new Error(
                axios.isAxiosError(error) && error.response?.data?.error
                    ? error.response.data.error
                    : 'Login failed'
            );
        }
    },

    /**
     * Verify email with token
     * GET /verify-email?token={token}
     */
    async verifyEmail(token: string): Promise<EmailVerificationResponse> {
        try {
            const response: AxiosResponse<EmailVerificationResponse> = await apiClient.get(
                `/verify-email?token=${encodeURIComponent(token)}`
            );
            return response.data;
        } catch (error) {
            console.error('Error verifying email:', error);
            throw new Error(
                axios.isAxiosError(error) && error.response?.data?.error
                    ? error.response.data.error
                    : 'Email verification failed'
            );
        }
    },
};

/**
 * Utility functions for user operations
 */
export const userUtils = {
    /**
     * Get user's full name
     */
    getFullName(user: User): string {
        if (user.name) return user.name;

        const parts = [];
        if (user.given_name) parts.push(user.given_name);
        if (user.middle_name) parts.push(user.middle_name);
        if (user.family_name) parts.push(user.family_name);

        return parts.length > 0 ? parts.join(' ') : user.email || 'Unknown User';
    },

    /**
     * Get user's display name (shorter version)
     */
    getDisplayName(user: User): string {
        if (user.name) return user.name;
        if (user.given_name && user.family_name) {
            return `${user.given_name} ${user.family_name}`;
        }
        if (user.given_name) return user.given_name;
        return user.email || 'Unknown User';
    },

    /**
     * Check if user email is verified
     */
    isEmailVerified(user: User): boolean {
        return !user.verification_token || user.verification_token === '';
    },

    /**
     * Get user status display information
     */
    getStatusInfo(status: string) {
        const statusMap: Record<string, { label: string; color: string; description: string }> = {
            [AccountStatus.ACTIVE]: {
                label: 'Active',
                color: 'green',
                description: 'Account is active and fully functional',
            },
            [AccountStatus.PENDING]: {
                label: 'Pending',
                color: 'yellow',
                description: 'Account is awaiting approval or verification',
            },
            [AccountStatus.SUSPENDED]: {
                label: 'Suspended',
                color: 'red',
                description: 'Account has been suspended',
            },
            [AccountStatus.COMPLETE]: {
                label: 'Complete',
                color: 'green',
                description: 'Account setup is complete',
            },
            [AccountStatus.INCOMPLETE]: {
                label: 'Incomplete',
                color: 'orange',
                description: 'Account setup is incomplete',
            },
            [AccountStatus.REJECTED]: {
                label: 'Rejected',
                color: 'red',
                description: 'Account application was rejected',
            },
        };

        return statusMap[status] || {
            label: status || 'Unknown',
            color: 'gray',
            description: 'Unknown status',
        };
    },

    /**
     * Get account type display information
     */
    getAccountTypeInfo(accountType: string) {
        const typeMap: Record<string, { label: string; icon: string; description: string }> = {
            [AccountType.PATIENT]: {
                label: 'Patient',
                icon: 'üë§',
                description: 'Patient account',
            },
            [AccountType.PROVIDER]: {
                label: 'Provider',
                icon: 'üë®‚Äç‚öïÔ∏è',
                description: 'Healthcare provider account',
            },
            [AccountType.PHARMACIST]: {
                label: 'Pharmacist',
                icon: 'üíä',
                description: 'Pharmacist account',
            },
            [AccountType.SUPPORT]: {
                label: 'Support',
                icon: 'üîß',
                description: 'Support staff account',
            },
        };

        return typeMap[accountType] || {
            label: accountType || 'Unknown',
            icon: '‚ùì',
            description: 'Unknown account type',
        };
    },

    /**
     * Validate email format
     */
    isValidEmail(email: string): boolean {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    },

    /**
     * Validate password strength
     */
    validatePassword(password: string): { isValid: boolean; errors: string[] } {
        const errors: string[] = [];

        if (password.length < 8) {
            errors.push('Password must be at least 8 characters long');
        }
        if (!/(?=.*[a-z])/.test(password)) {
            errors.push('Password must contain at least one lowercase letter');
        }
        if (!/(?=.*[A-Z])/.test(password)) {
            errors.push('Password must contain at least one uppercase letter');
        }
        if (!/(?=.*\d)/.test(password)) {
            errors.push('Password must contain at least one number');
        }
        if (!/(?=.*[@$!%*?&])/.test(password)) {
            errors.push('Password must contain at least one special character (@$!%*?&)');
        }

        return {
            isValid: errors.length === 0,
            errors,
        };
    },

    /**
     * Format user for display in tables or lists
     */
    formatUserForDisplay(user: User) {
        return {
            id: user.sub,
            name: this.getDisplayName(user),
            email: user.email,
            accountType: this.getAccountTypeInfo(user.account_type || '').label,
            status: this.getStatusInfo(user.status || '').label,
            isVerified: this.isEmailVerified(user),
            ...user,
        };
    },
};

/**
 * User API hooks for React components
 * These can be used with React Query or SWR for better data management
 */
export const userQueries = {
    /**
     * Query key factory for user-related queries
     */
    keys: {
        all: ['users'] as const,
        lists: () => [...userQueries.keys.all, 'list'] as const,
        list: (filters: Record<string, unknown>) => [...userQueries.keys.lists(), { filters }] as const,
        details: () => [...userQueries.keys.all, 'detail'] as const,
        detail: (id: string) => [...userQueries.keys.details(), id] as const,
    },

    /**
     * Query function for fetching all users
     */
    fetchUsers: () => userApi.listUsers(),

    /**
     * Query function for fetching a single user
     */
    fetchUser: (id: string) => userApi.getUserById(id),
};

// Export types for convenience
export { AccountStatus, AccountType };
export type { CreateUserData, LoginRequest, UpdateUserData, User };

export default userApi;
